<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Sound Collective</title>
    <style>
        :root {
            --background-color: #181818;
            --surface-color: #282828;
            --primary-color: #1DB954;
            --text-color: #FFFFFF;
            --text-secondary-color: #b3b3b3;
            --grid-cell-color: #404040;
            --grid-cell-active-color: #606060;
            --grid-cell-on-color: var(--primary-color);
            --row-alt-color: rgba(0, 0, 0, 0.2);
            --font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
        }

        body {
            background-color: var(--background-color);
            color: var(--text-color);
            font-family: var(--font-family);
            margin: 0;
            padding: 20px;
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        h1 {
            color: var(--primary-color);
        }

        .app-container {
            width: 100%;
            max-width: 1200px;
            background-color: var(--surface-color);
            border-radius: 8px;
            padding: 20px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.2);
        }

        .controls {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 20px;
            margin-bottom: 20px;
            flex-wrap: wrap;
        }

        .controls button {
            background-color: var(--primary-color);
            color: var(--text-color);
            border: none;
            padding: 10px 20px;
            min-width: 110px;
            border-radius: 50px;
            font-size: 16px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            transition: background-color 0.2s, color 0.2s;
        }

        .controls button:hover {
            background-color: #1ed760;
        }

        .controls button:disabled {
            background-color: #555;
            color: #999;
            cursor: not-allowed;
        }

        .tempo-control-group {
            display: flex;
            flex-direction: column;
            gap: 5px;
            align-items: stretch;
            text-align: center;
        }

        .tempo-control-group label {
            font-size: 12px;
            color: var(--text-secondary-color);
            text-transform: uppercase;
        }

        .control-group {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .icon {
            width: 1.2em;
            height: 1.2em;
            color: var(--text-secondary-color);
            flex-shrink: 0;
        }

        input[type="range"] {
            -webkit-appearance: none;
            appearance: none;
            width: 100%;
            height: 8px;
            background: var(--grid-cell-color);
            border-radius: 5px;
            outline: none;
        }

        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 18px;
            height: 18px;
            background: var(--primary-color);
            border-radius: 50%;
            cursor: pointer;
        }

        input[type="range"]::-moz-range-thumb {
            width: 18px;
            height: 18px;
            background: var(--primary-color);
            border-radius: 50%;
            cursor: pointer;
        }

        select {
            background-color: var(--grid-cell-color);
            color: var(--text-color);
            border: 1px solid var(--background-color);
            border-radius: 4px;
            padding: 5px;
            font-family: var(--font-family);
            width: 100%;
        }

        .main-content {
            display: grid;
            grid-template-columns: 1fr repeat(16, 1fr);
            gap: 5px;
            align-items: center;
            margin-bottom: 20px;
        }

        .track-header {
            padding: 10px;
            border-radius: 4px;
            background-color: var(--row-alt-color);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            gap: 10px;
            font-size: 12px;
            font-weight: bold;
            text-align: center;
            height: 100%;
        }

        .track-header .icon {
            width: 1.5em;
            height: 1.5em;
        }

        .load-button {
            padding: 6px;
            background-color: var(--grid-cell-color);
            border-radius: 4px;
            cursor: pointer;
            color: var(--text-secondary-color);
            display: flex;
            align-items: center;
        }
        .load-button:hover {
            color: var(--text-color);
        }

        .track-label input[type="file"] {
            display: none;
        }

        .sequencer-cell {
            width: 100%;
            aspect-ratio: 1 / 1;
            background-color: var(--row-alt-color);
            border-radius: 4px;
            cursor: pointer;
            transition: background-color 0.1s;
        }

        .sequencer-cell.on {
            background-color: var(--grid-cell-on-color);
        }

        .sequencer-cell.current {
            box-shadow: inset 0 0 0 2px var(--text-secondary-color);
        }

        .track-controls-container {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 20px;
        }

        .track-control-panel {
            background-color: var(--row-alt-color);
            padding: 15px;
            border-radius: 8px;
            display: flex;
            flex-direction: column;
            gap: 15px;
        }

        .track-control-panel .track-label {
            font-weight: bold;
            font-size: 16px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .ai-prompt-container {
            display: flex;
            gap: 10px;
            margin: 20px 0;
            width: 100%;
            max-width: 700px;
        }

        #ai-prompt-input {
            flex-grow: 1;
            height: 40px;
            padding: 10px;
            border-radius: 4px;
            border: 1px solid var(--grid-cell-color);
            background-color: var(--background-color);
            color: var(--text-color);
            font-family: var(--font-family);
            resize: vertical;
            font-size: 14px;
        }

        #ai-submit-btn {
            background-color: var(--primary-color);
            color: var(--text-color);
            border: none;
            padding: 10px 20px;
            border-radius: 50px;
            font-size: 16px;
            cursor: pointer;
            transition: background-color 0.2s;
        }
        #ai-submit-btn:hover {
            background-color: #1ed760;
        }

        .api-key-container {
            display: flex;
            gap: 10px;
            width: 100%;
            align-items: center;
            margin-bottom: 10px;
        }

        #api-key-input {
            flex-grow: 1;
            padding: 8px;
            border-radius: 4px;
            border: 1px solid var(--grid-cell-color);
            background-color: var(--background-color);
            color: var(--text-color);
            font-family: var(--font-family);
        }

        #save-api-key-btn {
            padding: 8px 15px;
            border-radius: 4px;
            border: none;
            background-color: var(--grid-cell-color);
            color: var(--text-secondary-color);
            cursor: pointer;
            transition: background-color 0.2s;
        }

        #save-api-key-btn:hover {
            background-color: var(--grid-cell-active-color);
            color: var(--text-color);
        }

        .sparkle {
            position: absolute;
            width: 8px;
            height: 8px;
            background: white;
            border-radius: 50%;
            pointer-events: none;
            animation: sparkle-anim 0.6s forwards;
            box-shadow: 0 0 10px white, 0 0 20px white;
        }

        @keyframes sparkle-anim {
            0% {
                transform: scale(1) translate(0, 0);
                opacity: 1;
            }
            100% {
                transform: scale(0) translate(var(--tx), var(--ty));
                opacity: 0;
            }
        }

    </style>
</head>
<body>

    <div class="app-container">
        <h1>Sound Collective</h1>
        <div class="controls">
            <button id="play-stop-btn"></button>
            <button id="ai-generate-btn">Generate with AI âœ¨</button>
            <button id="sparkling-mode-btn">Sparkling Mode OFF</button>
            <div class="tempo-control-group">
                <label for="tempo-slider">Tempo</label>
                <input type="range" id="tempo-slider" min="60" max="240" value="120">
                <span id="tempo-display">120 BPM</span>
            </div>
        </div>

        <div class="ai-prompt-container" id="ai-prompt-container" style="display: none;">
            <div class="api-key-container">
                <input type="password" id="api-key-input" placeholder="Enter your Gemini API Key here">
                <button id="save-api-key-btn">Save Key</button>
            </div>
            <textarea id="ai-prompt-input" placeholder="e.g., a fast, complex trap hi-hat pattern with some triplets"></textarea>
            <button id="ai-submit-btn">Generate</button>
        </div>

        <div class="main-content" id="main-content"></div>
        <div class="track-controls-container" id="track-controls-container"></div>
    </div>

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            const NUM_TRACKS = 6;
            const NUM_STEPS = 16;
            const defaultTrackNames = ["Kick", "Snare", "Hi-Hat", "Clap", "Lead", "Pad"];

            const ICONS = {
                play: `<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="currentColor" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon"><polygon points="5 3 19 12 5 21 5 3"></polygon></svg>`, 
                stop: `<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="currentColor" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon"><rect x="6" y="6" width="12" height="12"></rect></svg>`, 
                volume: `<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon"><polygon points="11 5 6 9 2 9 2 15 6 15 11 19 11 5"></polygon><path d="M15.54 8.46a5 5 0 0 1 0 7.07"></path></svg>`, 
                filter: `<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon"><polygon points="22 3 2 3 10 12.46 10 19 14 21 14 12.46 22 3"></polygon></svg>`, 
                upload: `<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon"><path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"></path><polyline points="17 8 12 3 7 8"></polyline><line x1="12" y1="3" x2="12" y2="15"></line></svg>`, 
                soundwave: `<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon"><path d="M2 10h3v4H2zm5-4h3v12H7zm5-6h3v20h-3zm5 4h3v12h-3zm5-4h3v4h-3z"/></svg>`
            };

            let audioContext;
            let isInitialized = false;
            let sequencerState = Array(NUM_TRACKS).fill(0).map(() => Array(NUM_STEPS).fill(false));
            let audioBuffers = Array(NUM_TRACKS).fill(null);
            let trackVolumes = Array(NUM_TRACKS).fill(0.8);
            let trackFilters = Array(NUM_TRACKS).fill(20000);
            let trackFilterTypes = Array(NUM_TRACKS).fill('lowpass');

            let currentStep = 0;
            let isPlaying = false;
            let tempo = 120;
            let scheduler;
            let isSparklingMode = false;

            const playStopBtn = document.getElementById('play-stop-btn');
            const tempoSlider = document.getElementById('tempo-slider');
            const tempoDisplay = document.getElementById('tempo-display');
            const mainContentContainer = document.getElementById('main-content');
            const trackControlsContainer = document.getElementById('track-controls-container');
            const aiGenerateBtn = document.getElementById('ai-generate-btn');
            const sparklingModeBtn = document.getElementById('sparkling-mode-btn');
            const aiPromptContainer = document.getElementById('ai-prompt-container');
            const apiKeyInput = document.getElementById('api-key-input');
            const saveApiKeyBtn = document.getElementById('save-api-key-btn');
            const aiPromptInput = document.getElementById('ai-prompt-input');
            const aiSubmitBtn = document.getElementById('ai-submit-btn');

            // --- Sound Synthesis Functions (unchanged) ---
            async function createKick(context) {
                const duration = 0.5;
                const offlineCtx = new OfflineAudioContext(1, context.sampleRate * duration, context.sampleRate);
                const osc = offlineCtx.createOscillator();
                const gain = offlineCtx.createGain();
                osc.type = 'sine';
                osc.frequency.setValueAtTime(150, 0);
                osc.frequency.exponentialRampToValueAtTime(0.01, offlineCtx.currentTime + 0.4);
                gain.gain.setValueAtTime(1, 0);
                gain.gain.exponentialRampToValueAtTime(0.01, offlineCtx.currentTime + 0.4);
                osc.connect(gain);
                gain.connect(offlineCtx.destination);
                osc.start(0);
                osc.stop(offlineCtx.currentTime + 0.4);
                return await offlineCtx.startRendering();
            }

            async function createSnare(context) {
                const duration = 0.5;
                const offlineCtx = new OfflineAudioContext(1, context.sampleRate * duration, context.sampleRate);
                const bufferSize = offlineCtx.sampleRate * duration;
                const noiseBuffer = offlineCtx.createBuffer(1, bufferSize, offlineCtx.sampleRate);
                const output = noiseBuffer.getChannelData(0);
                for (let i = 0; i < bufferSize; i++) {
                    output[i] = Math.random() * 2 - 1;
                }
                const noiseSource = offlineCtx.createBufferSource();
                noiseSource.buffer = noiseBuffer;
                const noiseFilter = offlineCtx.createBiquadFilter();
                noiseFilter.type = 'highpass';
                noiseFilter.frequency.value = 1000;
                const noiseGain = offlineCtx.createGain();
                noiseGain.gain.setValueAtTime(1, 0);
                noiseGain.gain.exponentialRampToValueAtTime(0.01, offlineCtx.currentTime + 0.2);
                noiseSource.connect(noiseFilter).connect(noiseGain).connect(offlineCtx.destination);

                const osc = offlineCtx.createOscillator();
                osc.type = 'triangle';
                osc.frequency.value = 100;
                const oscGain = offlineCtx.createGain();
                oscGain.gain.setValueAtTime(0.7, 0);
                oscGain.gain.exponentialRampToValueAtTime(0.01, offlineCtx.currentTime + 0.1);
                osc.connect(oscGain).connect(offlineCtx.destination);

                noiseSource.start(0);
                osc.start(0);
                noiseSource.stop(offlineCtx.currentTime + 0.2);
                osc.stop(offlineCtx.currentTime + 0.2);
                return await offlineCtx.startRendering();
            }

            async function createHiHat(context) {
                const duration = 0.5;
                const offlineCtx = new OfflineAudioContext(1, context.sampleRate * duration, context.sampleRate);
                const bufferSize = offlineCtx.sampleRate * duration;
                const noiseBuffer = offlineCtx.createBuffer(1, bufferSize, offlineCtx.sampleRate);
                const output = noiseBuffer.getChannelData(0);
                for (let i = 0; i < bufferSize; i++) {
                    output[i] = Math.random() * 2 - 1;
                }
                const noiseSource = offlineCtx.createBufferSource();
                noiseSource.buffer = noiseBuffer;
                const noiseFilter = offlineCtx.createBiquadFilter();
                noiseFilter.type = 'highpass';
                noiseFilter.frequency.value = 7000;
                const noiseGain = offlineCtx.createGain();
                noiseGain.gain.setValueAtTime(1, 0);
                noiseGain.gain.exponentialRampToValueAtTime(0.01, offlineCtx.currentTime + 0.05);
                noiseSource.connect(noiseFilter).connect(noiseGain).connect(offlineCtx.destination);
                noiseSource.start(0);
                noiseSource.stop(offlineCtx.currentTime + 0.05);
                return await offlineCtx.startRendering();
            }

            async function createClap(context) {
                const duration = 1.0;
                const offlineCtx = new OfflineAudioContext(1, context.sampleRate * duration, context.sampleRate);
                const bufferSize = offlineCtx.sampleRate * duration;
                const noiseBuffer = offlineCtx.createBuffer(1, bufferSize, offlineCtx.sampleRate);
                const output = noiseBuffer.getChannelData(0);
                for (let i = 0; i < bufferSize; i++) {
                    output[i] = Math.random() * 2 - 1;
                }

                const noiseGain = offlineCtx.createGain();
                noiseGain.gain.setValueAtTime(1, 0.001);
                noiseGain.gain.exponentialRampToValueAtTime(0.4, offlineCtx.currentTime + 0.02);
                noiseGain.gain.setValueAtTime(1, 0.021);
                noiseGain.gain.exponentialRampToValueAtTime(0.4, offlineCtx.currentTime + 0.04);
                noiseGain.gain.setValueAtTime(1, 0.041);
                noiseGain.gain.exponentialRampToValueAtTime(0.01, offlineCtx.currentTime + 0.2);

                const filter = offlineCtx.createBiquadFilter();
                filter.type = "bandpass";
                filter.frequency.value = 1500;

                const noiseSource = offlineCtx.createBufferSource();
                noiseSource.buffer = noiseBuffer;
                noiseSource.connect(filter).connect(noiseGain).connect(offlineCtx.destination);
                noiseSource.start(0);

                return await offlineCtx.startRendering();
            }

            async function createSynthLead(context) {
                const duration = 0.5;
                const offlineCtx = new OfflineAudioContext(1, context.sampleRate * duration, context.sampleRate);
                const osc = offlineCtx.createOscillator();
                const gain = offlineCtx.createGain();
                osc.type = 'sawtooth';
                osc.frequency.setValueAtTime(440, 0);
                gain.gain.setValueAtTime(0.5, 0);
                gain.gain.exponentialRampToValueAtTime(0.01, offlineCtx.currentTime + 0.4);
                osc.connect(gain);
                gain.connect(offlineCtx.destination);
                osc.start(0);
                osc.stop(offlineCtx.currentTime + 0.4);
                return await offlineCtx.startRendering();
            }

            async function createSynthPad(context) {
                const duration = 2.0;
                const offlineCtx = new OfflineAudioContext(1, context.sampleRate * duration, context.sampleRate);
                const osc1 = offlineCtx.createOscillator();
                const osc2 = offlineCtx.createOscillator();
                const gain = offlineCtx.createGain();
                osc1.type = 'triangle';
                osc1.frequency.setValueAtTime(220, 0);
                osc2.type = 'sine';
                osc2.frequency.setValueAtTime(220.5, 0); // Slightly detuned
                gain.gain.setValueAtTime(0.3, 0);
                gain.gain.exponentialRampToValueAtTime(0.01, offlineCtx.currentTime + 1.9);
                osc1.connect(gain);
                osc2.connect(gain);
                gain.connect(offlineCtx.destination);
                osc1.start(0);
                osc2.start(0);
                osc1.stop(offlineCtx.currentTime + 1.9);
                osc2.stop(offlineCtx.currentTime + 1.9);
                return await offlineCtx.startRendering();
            }

            async function createDefaultSamples() {
                if (!audioContext) return;
                console.log("Creating default samples...");
                try {
                    const [kick, snare, hihat, clap, lead, pad] = await Promise.all([
                        createKick(audioContext),
                        createSnare(audioContext),
                        createHiHat(audioContext),
                        createClap(audioContext),
                        createSynthLead(audioContext),
                        createSynthPad(audioContext)
                    ]);
                    audioBuffers[0] = kick;
                    audioBuffers[1] = snare;
                    audioBuffers[2] = hihat;
                    audioBuffers[3] = clap;
                    audioBuffers[4] = lead;
                    audioBuffers[5] = pad;
                    console.log("Default samples created.");
                } catch (e) {
                    console.error("Failed to create default samples:", e);
                    alert("Could not create default sounds. You can still load your own samples.");
                }
            }

            function initAudioContext() {
                if (!audioContext) {
                    try {
                        audioContext = new (window.AudioContext || window.webkitAudioContext)();
                        console.log("AudioContext created successfully.");
                    } catch (e) {
                        alert('Web Audio API is not supported in this browser');
                        console.error(e);
                    }
                }
                if (audioContext.state === 'suspended') {
                    audioContext.resume();
                }
            }

            function createUI() {
                mainContentContainer.innerHTML = '';
                trackControlsContainer.innerHTML = '';

                for (let i = 0; i < NUM_TRACKS; i++) {
                    // Create Track Header in the main grid
                    const trackHeader = document.createElement('div');
                    trackHeader.classList.add('track-header');
                    trackHeader.innerHTML = `
                        ${ICONS.soundwave}
                        <span id="track-name-header-${i}">${defaultTrackNames[i]}</span>
                    `;
                    mainContentContainer.appendChild(trackHeader);

                    // Create Sequencer Cells
                    for (let j = 0; j < NUM_STEPS; j++) {
                        const cell = document.createElement('div');
                        cell.classList.add('sequencer-cell');
                        cell.dataset.track = i;
                        cell.dataset.step = j;
                        if (sequencerState[i][j]) cell.classList.add('on');
                        mainContentContainer.appendChild(cell);
                    }

                    // Create Track Control Panel
                    const controlPanel = document.createElement('div');
                    controlPanel.classList.add('track-control-panel');
                    controlPanel.innerHTML = `
                        <div class="track-label">
                            <span id="track-name-control-${i}">${defaultTrackNames[i]}</span>
                            <label class="load-button" title="Load custom sample">
                                ${ICONS.upload}
                                <input type="file" class="load-sample-input" data-track-index="${i}" accept="audio/*">
                            </label>
                        </div>
                        <div class="control-group" title="Volume">
                            ${ICONS.volume}
                            <input type="range" class="volume-slider" data-track-index="${i}" min="0" max="1" step="0.01" value="${trackVolumes[i]}">
                        </div>
                        <div class="control-group" title="Filter Frequency">
                            ${ICONS.filter}
                            <input type="range" class="filter-slider" data-track-index="${i}" min="100" max="20000" step="10" value="${trackFilters[i]}">
                        </div>
                        <div class="control-group" title="Filter Type">
                            <select class="filter-type-select" data-track-index="${i}">
                                <option value="lowpass" ${trackFilterTypes[i] === 'lowpass' ? 'selected' : ''}>Low-Pass</option>
                                <option value="highpass" ${trackFilterTypes[i] === 'highpass' ? 'selected' : ''}>High-Pass</option>
                            </select>
                        </div>
                    `;
                    trackControlsContainer.appendChild(controlPanel);
                }
                setupAllEventListeners();
            }

            function setupAllEventListeners() {
                playStopBtn.addEventListener('click', handlePlayClick);

                sparklingModeBtn.addEventListener('click', () => {
                    isSparklingMode = !isSparklingMode;
                    sparklingModeBtn.textContent = `Sparkling Mode ${isSparklingMode ? 'ON' : 'OFF'}`;
                    sparklingModeBtn.style.backgroundColor = isSparklingMode ? '#1ed760' : 'var(--primary-color)';
                });

                aiGenerateBtn.addEventListener('click', () => {
                    const isHidden = aiPromptContainer.style.display === 'none';
                    aiPromptContainer.style.display = isHidden ? 'block' : 'none';
                });

                saveApiKeyBtn.addEventListener('click', () => {
                    const apiKey = apiKeyInput.value.trim();
                    if (apiKey) {
                        sessionStorage.setItem('gemini-api-key', apiKey);
                        alert('API Key saved for this session.');
                        apiKeyInput.value = '';
                        apiKeyInput.placeholder = 'Key Saved!';
                    } else {
                        alert('Please enter a valid API key.');
                    }
                });

                aiSubmitBtn.addEventListener('click', handleAIGenerate);

                tempoSlider.addEventListener('input', (e) => {
                    tempo = parseInt(e.target.value, 10);
                    tempoDisplay.textContent = `${tempo} BPM`;
                    if (isPlaying) {
                        clearInterval(scheduler);
                        const secondsPerStep = (60.0 / tempo) / 4;
                        scheduler = setInterval(nextStep, secondsPerStep * 1000);
                    }
                });

                mainContentContainer.addEventListener('click', (e) => {
                    if (e.target.classList.contains('sequencer-cell')) {
                        const track = parseInt(e.target.dataset.track, 10);
                        const step = parseInt(e.target.dataset.step, 10);
                        sequencerState[track][step] = !sequencerState[track][step];
                        e.target.classList.toggle('on', sequencerState[track][step]);
                    }
                });

                document.querySelectorAll('.load-sample-input').forEach(input => {
                    input.addEventListener('change', (e) => loadSample(e));
                });

                document.querySelectorAll('.volume-slider').forEach(slider => {
                    slider.addEventListener('input', (e) => {
                        const trackIndex = parseInt(e.target.dataset.trackIndex, 10);
                        trackVolumes[trackIndex] = parseFloat(e.target.value);
                    });
                });

                document.querySelectorAll('.filter-slider').forEach(slider => {
                    slider.addEventListener('input', (e) => {
                        const trackIndex = parseInt(e.target.dataset.trackIndex, 10);
                        trackFilters[trackIndex] = parseFloat(e.target.value);
                    });
                });

                document.querySelectorAll('.filter-type-select').forEach(select => {
                    select.addEventListener('change', (e) => {
                        const trackIndex = parseInt(e.target.dataset.trackIndex, 10);
                        trackFilterTypes[trackIndex] = e.target.value;
                    });
                });
            }

            function createSparkle(cell) {
                const rect = cell.getBoundingClientRect();
                const containerRect = document.body.getBoundingClientRect();
                const colors = ['#FFD700', '#FF1493', '#00FFFF', '#ADFF2F', '#FFFFFF'];

                for (let i = 0; i < 20; i++) { // Increased particle count
                    const sparkle = document.createElement('div');
                    sparkle.classList.add('sparkle');
                    
                    const x = rect.left - containerRect.left + rect.width / 2;
                    const y = rect.top - containerRect.top + rect.height / 2;
                    sparkle.style.left = `${x}px`;
                    sparkle.style.top = `${y}px`;

                    const color = colors[Math.floor(Math.random() * colors.length)];
                    const size = Math.random() * 10 + 4; // Size variation
                    sparkle.style.backgroundColor = color;
                    sparkle.style.width = `${size}px`;
                    sparkle.style.height = `${size}px`;
                    sparkle.style.boxShadow = `0 0 10px ${color}, 0 0 20px ${color}`;

                    const angle = Math.random() * 2 * Math.PI;
                    const distance = Math.random() * 50 + 30; // Increased distance
                    const tx = `${Math.cos(angle) * distance}px`;
                    const ty = `${Math.sin(angle) * distance}px`;

                    sparkle.style.setProperty('--tx', tx);
                    sparkle.style.setProperty('--ty', ty);

                    document.body.appendChild(sparkle);
                    sparkle.addEventListener('animationend', () => {
                        sparkle.remove();
                    });
                }
            }

            function updateGridFromState() {
                for (let i = 0; i < NUM_TRACKS; i++) {
                    for (let j = 0; j < NUM_STEPS; j++) {
                        const cell = document.querySelector(`.sequencer-cell[data-track='${i}'][data-step='${j}']`);
                        if (cell) {
                            cell.classList.toggle('on', sequencerState[i][j]);
                        }
                    }
                }
            }

            async function handleAIGenerate() {
                const apiKey = sessionStorage.getItem('gemini-api-key');
                if (!apiKey) {
                    alert('Please enter and save your Gemini API Key first.');
                    return;
                }

                const userPrompt = aiPromptInput.value.trim();
                if (!userPrompt) {
                    alert('Please enter a description for the beat you want to generate.');
                    return;
                }

                aiSubmitBtn.disabled = true;
                aiSubmitBtn.textContent = 'Generating...';

                const API_ENDPOINT = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash:generateContent?key=${apiKey}`;
                const systemPrompt = `You are an expert drum machine programmer. Your task is to generate a 16-step sequencer pattern based on the user's description. The application has 4 tracks: 'kick', 'snare', 'hiHat', and 'clap'. Please provide the output ONLY as a valid JSON object. The object must have keys named 'kick', 'snare', 'hiHat', and 'clap'. Each key's value must be an array of exactly 16 booleans (true for an active step, false for an inactive step). Do not include any other text, explanations, or markdown formatting in your response. Just the raw JSON. User's description: '${userPrompt}'`;

                try {
                    const response = await fetch(API_ENDPOINT, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                        },
                        body: JSON.stringify({
                            contents: [{
                                parts: [{
                                    text: systemPrompt
                                }]
                            }]
                        })
                    });

                    if (!response.ok) {
                        const errorData = await response.json();
                        throw new Error(`API Error (${response.status}): ${errorData.error.message}`);
                    }

                    const data = await response.json();
                    const jsonString = data.candidates[0].content.parts[0].text;
                    const match = jsonString.match(/```json\n([\s\S]*)\n```/);
                    let cleanedJsonString;
                    if (match) {
                        cleanedJsonString = match[1];
                    } else {
                        cleanedJsonString = jsonString;
                    }

                    const pattern = JSON.parse(cleanedJsonString);

                    if (!pattern.kick || !pattern.snare || !pattern.hiHat || !pattern.clap) {
                        throw new Error("The AI response was missing one or more required tracks.");
                    }

                    sequencerState[0] = pattern.kick;
                    sequencerState[1] = pattern.snare;
                    sequencerState[2] = pattern.hiHat;
                    sequencerState[3] = pattern.clap;

                    updateGridFromState();
                    aiPromptContainer.style.display = 'none';

                } catch (error) {
                    console.error('Generation failed:', error);
                    alert(`Failed to generate pattern: ${error.message}`);
                } finally {
                    aiSubmitBtn.disabled = false;
                    aiSubmitBtn.textContent = 'Generate';
                }
            }

            function updatePlayButton(state) {
                if (state === 'playing') {
                    playStopBtn.innerHTML = `${ICONS.stop} Stop`;
                } else if (state === 'stopped') {
                    playStopBtn.innerHTML = `${ICONS.play} Play`;
                } else if (state === 'loading') {
                    playStopBtn.textContent = 'Loading...';
                    playStopBtn.disabled = true;
                }
            }

            async function handlePlayClick() {
                if (!isInitialized) {
                    updatePlayButton('loading');
                    initAudioContext();
                    await createDefaultSamples();
                    isInitialized = true;
                    playStopBtn.disabled = false;
                }
                togglePlayback();
            }

            async function loadSample(event) {
                const file = event.target.files[0];
                if (!file || !audioContext) return;

                const trackIndex = parseInt(event.target.dataset.trackIndex, 10);
                const reader = new FileReader();

                reader.onload = async (e) => {
                    try {
                        const buffer = await audioContext.decodeAudioData(e.target.result);
                        audioBuffers[trackIndex] = buffer;
                        const trackName = file.name.length > 12 ? file.name.substring(0, 10) + '...' : file.name;
                        document.getElementById(`track-name-header-${trackIndex}`).textContent = trackName;
                        document.getElementById(`track-name-control-${trackIndex}`).textContent = trackName;
                        console.log(`Sample loaded for track ${trackIndex + 1}`);
                    } catch (err) {
                        alert(`Error decoding audio file: ${err.message}`);
                    }
                };
                reader.readAsArrayBuffer(file);
            }

            function playSound(trackIndex, time) {
                if (!audioBuffers[trackIndex] || !audioContext) return;

                const source = audioContext.createBufferSource();
                source.buffer = audioBuffers[trackIndex];

                if (isSparklingMode) {
                    const cell = document.querySelector(`.sequencer-cell[data-track='${trackIndex}'][data-step='${currentStep}']`);
                    if(cell) createSparkle(cell);

                    // Add sound variations for sparkling mode
                    const playbackRate = 1 + (Math.random() - 0.5) * 0.4; // +/- 20%
                    source.playbackRate.setValueAtTime(playbackRate, time);
                    
                    const detuneAmount = (Math.random() - 0.5) * 600; // +/- 300 cents
                    source.detune.setValueAtTime(detuneAmount, time);
                }

                const filter = audioContext.createBiquadFilter();
                filter.type = trackFilterTypes[trackIndex];
                filter.frequency.setValueAtTime(trackFilters[trackIndex], time);

                const gain = audioContext.createGain();
                gain.gain.setValueAtTime(trackVolumes[trackIndex], time);

                source.connect(filter).connect(gain).connect(audioContext.destination);
                source.start(time);
            }

            function scheduleNextStep() {
                const lookahead = 0.1;
                const scheduleTime = audioContext.currentTime + lookahead;

                for (let track = 0; track < NUM_TRACKS; track++) {
                    if (sequencerState[track][currentStep]) {
                        playSound(track, scheduleTime);
                    }
                }
            }

            function updateUIForStep() {
                document.querySelectorAll('.sequencer-cell.current').forEach(cell => cell.classList.remove('current'));
                document.querySelectorAll(`[data-step="${currentStep}"]`).forEach(cell => cell.classList.add('current'));
            }

            function nextStep() {
                updateUIForStep();
                scheduleNextStep();
                currentStep = (currentStep + 1) % NUM_STEPS;
            }

            function togglePlayback() {
                isPlaying = !isPlaying;

                if (isPlaying) {
                    updatePlayButton('playing');
                    currentStep = 0;
                    const secondsPerStep = (60.0 / tempo) / 4;
                    nextStep();
                    scheduler = setInterval(nextStep, secondsPerStep * 1000);
                } else {
                    updatePlayButton('stopped');
                    clearInterval(scheduler);
                    document.querySelectorAll('.sequencer-cell.current').forEach(cell => cell.classList.remove('current'));
                }
            }

            // --- Initialize ---
            createUI();
            updatePlayButton('stopped');
        });
    </script>

</body>
</html>
